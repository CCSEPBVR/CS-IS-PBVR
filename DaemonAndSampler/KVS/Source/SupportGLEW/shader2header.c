/*****************************************************************************/
/**
 *  @file   shader2header.c
 *  @brief  Converts the GLSL shader codes to the C/C++ header file.
 *  @author Naohisa Sakamoto
 */
/*----------------------------------------------------------------------------
 *
 *  Copyright 2007 Visualization Laboratory, Kyoto University.
 *  All rights reserved.
 *  See http://www.viz.media.kyoto-u.ac.jp/kvs/copyright/ for details.
 *
 *  $Id: shader2header.c 473 2010-02-07 01:39:15Z naohisa.sakamoto $
 */
/*****************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if defined( _MSC_VER )
#include <windows.h>
#include <mbstring.h>
#include <direct.h>
#else
#include <dirent.h>
#endif

#define MAX_FILEPATH_LENGTH 256
#define MAX_LINE_LENGTH     256
#if defined ( _MSC_VER )
#define PATH_SEPARATOR "\\"
#else
#define PATH_SEPARATOR "/"
#endif

#define BEGIN_HEADER( fp, modulename )                                  \
    fprintf( fp, "/* DON'T EDIT THIS FILE.\n" );                        \
    fprintf( fp, " * THIS IS GENERATED BY \"%s\".\n", __FILE__ );       \
    fprintf( fp, " */\n" );                                             \
    fprintf( fp, "#ifndef KVS__GLEW__GLSL__%s_H_INCLUDE\n",   modulename ); \
    fprintf( fp, "#define KVS__GLEW__GLSL__%s_H_INCLUDE\n\n", modulename ); \
    fprintf( fp, "namespace kvs\n{\n\n" );                              \
    fprintf( fp, "namespace glew\n{\n\n" );                             \
    fprintf( fp, "namespace glsl\n{\n\n" )

#define BEGIN_NAMESPACE( fp, name )             \
    fprintf( fp, "namespace %s\n{\n\n", name )

#define END_NAMESPACE( fp, name )                       \
    fprintf( fp, "} // end of namespace %s\n\n", name )

#define END_HEADER( fp, modulename )                                    \
    fprintf( fp, "} // end of namespace glsl\n\n" );                    \
    fprintf( fp, "} // end of namesapce glew\n\n" );                    \
    fprintf( fp, "} // end of namespace kvs\n\n" );                     \
    fprintf( fp, "#endif // KVS__GLEW__GLSL__%s_H_INCLUDE\n", modulename )

/* For Microsoft Visual C/C++.
 */
#if defined( _MSC_VER )
enum
{
    MBTypeSB,
    MBTypeDB1,
    MBTypeDB2,
    MBTypeERR
}  MBCharType;

/*==========================================================================*/
/**
 *  @brief  Tests a string to determine whether it is lead-bytes of MB characters.
 *  @param  str [in] string
 *  @param  num [in] number of characters composed of the string
 *  @return nonezero, if the str is lead-bytes of multibyte characters.
 */
/*==========================================================================*/
int IsMBCharLeadByte( const char* str, int num )
{
    int k;
    if ( !_ismbblead( str[num] ) ) { return( 0 ); }
    k = num;
    while ( --k >= 0 && _ismbblead( str[k] ) )
    {
        ;
    }
    return( ( num - k ) & 1 );
}

/*==========================================================================*/
/**
 *  @brief  Returns a type of multibyte character.
 *  @param  str [in] string
 *  @param  num [in] number of characters composed of the string
 *  @return type of multibyte character.
 */
/*==========================================================================*/
enum MBCharType GetMBCharType( const char* str, int num )
{
    if ( num > 0 && IsMBCharLeadByte( str, num - 1 ) )
    {
        return( _ismbbtrail( str[num] ) ? MBTypeDB2 : MBTypeERR );
    }
    else
    {
        return( _ismbblead( str[num] ) ? MBTypeDB1 : MBTypeSB );
    }
}
#endif

/*===========================================================================*/
/**
 *  @brief  File list structure.
 */
/*===========================================================================*/
typedef struct FileList_t
{
    char dirname[MAX_FILEPATH_LENGTH];    /** directory name (ex. /usr/local) */
    char filename[MAX_FILEPATH_LENGTH];   /** filename (ex. abc.txt) */
    char basename[MAX_FILEPATH_LENGTH];   /** basename (ex. abc) */
    char filepath[MAX_FILEPATH_LENGTH*2]; /** file path (ex. /usr/local/abc.txt) */
    struct FileList_t* next;              /** pointer to the next file */
} FileList;

/*===========================================================================*/
/**
 *  @brief  Adds a file information to the list.
 *  @param  dirname [in] directory name 
 *  @param  filename [in] filename
 *  @param  head [in] pointer to the head of the list
 *  @return pointer to the added file.
 */
/*===========================================================================*/
FileList* FileList_add( const char* dirname, const char* filename, FileList* head )
{
    FileList* f = (FileList*)calloc( 1, sizeof( FileList ) );
    if ( !f ) return( NULL );

    memset( f->dirname,  0, MAX_FILEPATH_LENGTH );
    memset( f->filename, 0, MAX_FILEPATH_LENGTH );
    memset( f->basename, 0, MAX_FILEPATH_LENGTH );
    memset( f->filepath, 0, MAX_FILEPATH_LENGTH*2 );

    strcpy(  f->dirname,  dirname ); if ( f->dirname[ strlen( dirname ) - 1 ] == '\n' ) f->dirname[ strlen( dirname ) - 1 ] = '\0';
    strcpy(  f->filename, filename );
    strcpy(  f->basename, filename ); *strrchr( f->basename, '.' ) = '\0';
    sprintf( f->filepath, "%s%s%s", f->dirname, PATH_SEPARATOR, filename );
//    strcat( f->filepath, dirname );
//    strcat( f->filepath, PATH_SEPARATOR );
//    strcat( f->filepath, filename );

    f->next = head;
    head = f;

    return( f );
}

/*===========================================================================*/
/**
 *  @brief  Frees the list.
 *  @param  head [in] pointer to the head of the list
 */
/*===========================================================================*/
void FileList_free( FileList* head )
{
    FileList* temp = NULL;
    while ( head != NULL )
    {
        temp = head->next;
        free( head );
        head = temp;
    }
}

/*===========================================================================*/
/**
 *  @brief  Creates shader file lists.
 *  @param  dirname [in] directory name
 *  @param  vert_list [out] pointer to the vertex shader list
 *  @param  frag_list [out] pointer to the fragment shader list
 */
/*===========================================================================*/
void CreateShaderFileList( const char* dirname, FileList** vert_list, FileList** frag_list )
{
#if defined( _MSC_VER )
    WIN32_FIND_DATAA find_data;
    HANDLE hFind;

    char bufname[256];
    int len;

    strcpy( bufname, dirname );

    /* If len is 0, dirname is empty. so I must get current directory
     * entry(i.e. "*.*") and must not add '\'.
     */
    len = strlen( bufname );
    if ( len )
    {
        if ( bufname[len - 1] != '\\' || GetMBCharType( bufname, len - 1 ) == MBTypeDB2 )
        {
            bufname[len++] = '\\';
        }
    }

    strcpy( bufname + len, "*.*" );
    hFind = FindFirstFileA( bufname, &find_data );
    {
        do
        {
            const char* filename = find_data.cFileName;

            /* Ignore dot file (.*) and "Shader.h" */
            if ( filename[0] == '.' ||
                 strncmp( filename, "Shader.h", 8 ) == 0 ) continue;

            /* Find *.vert and *.frag */
            if ( strcmp( ".vert", strrchr( filename, '.' ) ) == 0 )
            {
                *vert_list = FileList_add( dirname, filename, *vert_list );
            }
            else if ( strcmp( ".frag", strrchr( filename, '.' ) ) == 0 )
            {
                *frag_list = FileList_add( dirname, filename, *frag_list );
            }
        }
        while ( FindNextFileA( hFind, &find_data ) );
    }
    FindClose( hFind );

#else
    DIR* directory = opendir( dirname );
    {
        struct dirent* ent = NULL;
        while ( ( ent = readdir( directory ) ) != NULL )
        {
            /* Ignore dot file (.*) and "Shader.h" */
            if ( ent->d_name[0] == '.' ||
                 strncmp( ent->d_name, "Shader.h", 8 ) == 0 ) continue;

            /* Find *.vert and *.frag */
            const char* filename = ent->d_name;
            if ( strcmp( ".vert", strrchr( filename, '.' ) ) == 0 )
            {
                *vert_list = FileList_add( dirname, filename, *vert_list );
            }
            else if ( strcmp( ".frag", strrchr( filename, '.' ) ) == 0 )
            {
                *frag_list = FileList_add( dirname, filename, *frag_list );
            }
        }
    }
    closedir( directory );
#endif
}

/*===========================================================================*/
/**
 *  @brief  Writes the shader codes.
 *  @param  fp [in] pointer to the output header file
 *  @param  shader_list [in] pointer to the shader file list
 */
/*===========================================================================*/
void WriteShaders( FILE* fp, FileList* shader_list )
{
    FileList* shader_file = shader_list;
    while ( shader_file != NULL )
    {
        FILE* file = NULL;
        if ( ( file = fopen( shader_file->filepath, "r" ) ) == NULL ) return;
        {
            char line[MAX_LINE_LENGTH];

            fprintf( stdout, "\t%s\n", shader_file->filepath );
            fprintf( fp, "const char* %s =\n", shader_file->basename );
            while ( fgets( line, MAX_LINE_LENGTH, file ) != NULL )
            {
                /* Ignore header comment line (Doxygen comment) */
                if ( strncmp( line, "/**", 3 ) == 0 ||
                     strncmp( line, "/*-", 3 ) == 0 ||
                     strncmp( line, "/*=", 3 ) == 0 ||
                     strncmp( line, " *",  2 ) == 0 ||
                     strncmp( line, " */", 3 ) == 0 ) continue;
                line[strlen(line)-1] = '\0';
                fprintf( fp, "    \"%s\\n\"\n", line );
            }
            fprintf( fp, ";\n\n" );
        }
        fclose( file );

        shader_file = shader_file->next;
    }
}

/*===========================================================================*/
/**
 *  @brief  Main function.
 *  @param  argc [in] argument count
 *  @param  argv [in] argument value
 */
/*===========================================================================*/
int main( int argc, char** argv )
{
    char* shader_dir_list = argv[1];
    FILE* shader_dir_list_fp = NULL;

    if ( ( shader_dir_list_fp = fopen( shader_dir_list, "r" ) ) == NULL )
    {
        fprintf( stderr, "Cannot open %s.\n", argv[1] );
        return( 1 );
    }
    else
    {
        char dirname[MAX_LINE_LENGTH]; /* directory name */
        memset( dirname, 0, MAX_LINE_LENGTH );
        while ( fgets( dirname, MAX_LINE_LENGTH, shader_dir_list_fp ) != NULL )
        {
            char* filename = "Shader.h"; /* output header file name */
            char  filepath[MAX_LINE_LENGTH]; /* dirname + filename */
            FILE* fp = NULL; /* file pointer to the output file */

            if ( dirname[ strlen( dirname ) - 1 ] == '\n' ) dirname[ strlen( dirname ) - 1 ] = '\0';

            /* Get the output file name (filepath). */
            memset( filepath, 0, MAX_LINE_LENGTH );
            sprintf( filepath, "%s%s%s", dirname, PATH_SEPARATOR, filename );
//            strcat( filepath, dirname );
//            strcat( filepath, PATH_SEPARATOR );
//            strcat( filepath, filename );

            /* Write the shader codes to the C/C++ header file ("Shader.h"). */
            if ( ( fp = fopen( filepath, "w" ) ) == NULL )
            {
                fprintf( stderr, "Cannot open %s.\n", filepath );
                continue;
            }
            else
            {
                char* modulename = dirname;
                if ( modulename = strstr( dirname, "/" ) ) modulename += strlen( "/" );
                BEGIN_HEADER( fp, modulename );
                BEGIN_NAMESPACE( fp, modulename );
                {
                    FileList* vert_list = NULL;
                    FileList* frag_list = NULL;

                    fprintf( stdout, "%s was created.\n", filepath );

                    /* Get shader file lists. */
                    CreateShaderFileList( dirname, &vert_list, &frag_list );

                    /* For vertex shaders. */
                    BEGIN_NAMESPACE( fp, "Vertex" );
                    WriteShaders( fp, vert_list );
                    END_NAMESPACE( fp, "Vertex" );

                    /* For fragment shaders. */
                    BEGIN_NAMESPACE( fp, "Fragment" );
                    WriteShaders( fp, frag_list );
                    END_NAMESPACE( fp, "Fragment" );

                    FileList_free( vert_list );
                    FileList_free( frag_list );
                }
                END_NAMESPACE( fp, modulename );
                END_HEADER( fp, modulename );

                fclose( fp );
            }
        }

        fclose( shader_dir_list_fp );
    }

    return( 0 );
}
