/* DONT'T EDIT THIS FILE.
 * THIS IS GENERATED BY "Configure/configure_shader.py".
 */
#ifndef KVS__GLEW__GLSL__ParticleVolumeRenderer_H_INCLUDE
#define KVS__GLEW__GLSL__ParticleVolumeRenderer_H_INCLUDE

namespace kvs { namespace glew { namespace glsl {

namespace ParticleVolumeRenderer
{

namespace Vertex
{

const char* resize =
    "\n"
    "void main( void )\n"
    "{\n"
    "    gl_Position = ftransform();\n"
    "    gl_TexCoord[0] = gl_MultiTexCoord0;\n"
    "    gl_FrontColor = gl_Color;\n"
    "}\n"
;

const char* zooming =
    "uniform float densityFactor;\n"
    "uniform int circle_threshold;\n"
    "uniform vec2 screen_scale;\n"
    "#if defined( ENABLE_RANDOM_TEXTURE )\n"
    "uniform sampler2D random_texture;\n"
    "uniform float random_texture_size_inv;\n"
    "attribute vec2 identifier;\n"
    "#endif\n"
    "\n"
    "const float CIRCLE_SCALE = 0.564189583547756; // 1.0 / sqrt(PI)\n"
    "\n"
    "varying vec3  position;\n"
    "varying vec3  normal;\n"
    "varying vec2  center;\n"
    "varying float radius;\n"
    "\n"
    "\n"
    "#if defined( ENABLE_RANDOM_TEXTURE )\n"
    "float zooming( in vec4 p )\n"
    "{\n"
    "    // Depth value.\n"
    "    float D = p.z;\n"
    "    if ( D < 1.0 ) D = 1.0; // to avoid front-clip\n"
    "\n"
    "    // Calculate the footprint size of the particle.\n"
    "    float s = densityFactor / D; // footprint size of the particle in pixel\n"
    "    float sf = floor( s );       // round-down value of s\n"
    "    float sc = ceil( s );        // round-up value of s\n"
    "\n"
    "    // Calculate a probability 'pc' that the footprint size is 'sc'.\n"
    "    float fraction = fract( s );\n"
    "    float pc = fraction * ( 2.0 * sf + fraction ) / ( 2.0 * sf + 1.0 );\n"
    "\n"
    "    // Random number from the random number texture.\n"
    "    vec2 random_texture_index = identifier * random_texture_size_inv;\n"
    "    float R = texture2D( random_texture, random_texture_index ).x;\n"
    "\n"
    "    if ( circle_threshold <= 0 || s <= float( circle_threshold ) )\n"
    "    {\n"
    "        // Draw the particle as square.\n"
    "        s = ( ( R < pc ) ? sc : sf );\n"
    "        radius = 0.0;\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        // Draw the particle as circle.\n"
    "        // Convert position to screen coordinates.\n"
    "        center = screen_scale + ( ( p.xy / p.w ) * screen_scale );\n"
    "        radius = ( ( R < pc ) ? sc : sf ) * CIRCLE_SCALE;\n"
    "        s = ceil( s * CIRCLE_SCALE * 2.0 ) + 1.0;\n"
    "    }\n"
    "\n"
    "    return( s );\n"
    "}\n"
    "\n"
    "#else\n"
    "float zooming( in vec4 p )\n"
    "{\n"
    "    // Depth value.\n"
    "    float D = p.z;\n"
    "    if ( D < 1.0 ) D = 1.0; // to avoid front-clip\n"
    "\n"
    "    // Calculate the footprint size of the particle.\n"
    "    float s = densityFactor / D; // footprint size of the particle in pixel\n"
    "    float sf = floor( s );       // round-down value of s\n"
    "    float sc = ceil( s );        // round-up value of s\n"
    "\n"
    "    // Calculate a probability 'pc' that the footprint size is 'sc'.\n"
    "    float fraction = fract( s );\n"
    "    float pc = fraction * ( 2.0 * sf + fraction ) / ( 2.0 * sf + 1.0 );\n"
    "\n"
    "    // Generate a random floating point using the vertex position.\n"
    "    float myF = p.x + p.z * p.y;\n"
    "    int Ri = int( myF * float( 0x0000ffff ) ); // pick 4 bits using mask\n"
    "    Ri = Ri & 0x000000f0;\n"
    "    Ri >>= 4;\n"
    "    float Rf = float( Ri ) / 16.0;\n"
    "    float R = Rf + sf;\n"
    "\n"
    "    if ( circle_threshold <= 0 || s <= float( circle_threshold ) )\n"
    "    {\n"
    "        // Draw the particle as square.\n"
    "        s = ( ( R < pc ) ? sc : sf );\n"
    "        radius = 0.0;\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        // Draw the particle as circle.\n"
    "        // Convert position to screen coordinates.\n"
    "        center = screen_scale + ( ( p.xy / p.w ) * screen_scale );\n"
    "        radius = ( ( R < pc ) ? sc : sf ) * CIRCLE_SCALE;\n"
    "        s = ceil( s * CIRCLE_SCALE * 2.0 ) + 1.0;\n"
    "    }\n"
    "\n"
    "    return( s );\n"
    "}\n"
    "#endif\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    gl_FrontColor = gl_Color;\n"
    "    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; // same as 'ftransform()'\n"
    "\n"
    "    normal = gl_Normal.xyz;\n"
    "    position = vec3( gl_ModelViewMatrix * gl_Vertex );\n"
    "\n"
    "#if defined( ENABLE_ZOOMING )\n"
    "    gl_PointSize = zooming( gl_Position );\n"
    "#else\n"
    "    radius = 0.0;\n"
    "    center = vec2(0.0);\n"
    "    gl_PointSize = 1.0;\n"
    "#endif\n"
    "}\n"
;

} // end of namespace Vertex

namespace Fragment
{

const char* resize =
    "uniform sampler2D texture;\n"
    "uniform vec2 start;\n"
    "uniform vec2 step;\n"
    "uniform ivec2 count;\n"
    "uniform float scale;\n"
    "\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "#if 0 // don't use linear interpolation\n"
    "    int x, y;\n"
    "    vec2 pos1, pos2;\n"
    "    vec4 c = vec4( 0.0, 0.0, 0.0, 0.0 );\n"
    "    pos1 = gl_TexCoord[0].st + start;\n"
    "    for ( y = 0; y < count.t; y++ )\n"
    "    {\n"
    "        pos2 = pos1;\n"
    "        for ( x = 0; x < count.s; x++ )\n"
    "        {\n"
    "            c += texture2D( texture, pos2 );\n"
    "            pos2.s += step.s;\n"
    "        }\n"
    "        pos1.t += step.t;\n"
    "    }\n"
    "    gl_FragColor = c * scale;\n"
    "#else\n"
    "    int x, y;\n"
    "    vec2 pos1, pos2, pos3;\n"
    "    vec4 c = vec4( 0.0, 0.0, 0.0, 0.0 );\n"
    "    pos1 = gl_TexCoord[0].st + start;\n"
    "    float weightxy, weighty;\n"
    "    for ( y = 0; y < count.t; y++ )\n"
    "    {\n"
    "        pos2 = pos1;\n"
    "        if ( x+1 < count.s )\n"
    "        {\n"
    "            // vertical interpolation\n"
    "            weighty = 2.0;\n"
    "            pos2.t += step.t * 0.5;\n"
    "            y++;\n"
    "            pos1.t += step.t;\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            weighty = 1.0;\n"
    "        }\n"
    "        for ( x = 0; x < count.s; x++ )\n"
    "        {\n"
    "            weightxy = weighty;\n"
    "            pos3 = pos2;\n"
    "            if ( x+1 < count.s )\n"
    "            {\n"
    "                // horizontal interpolation\n"
    "                weightxy = weighty * 2.0;\n"
    "                pos3.s += step.s * 0.5;\n"
    "                x++;\n"
    "                pos2.s += step.s;\n"
    "            }\n"
    "            c += texture2D( texture, pos3 ) * weightxy;\n"
    "            pos2.s += step.s;\n"
    "        }\n"
    "        pos1.t += step.t;\n"
    "    }\n"
    "    gl_FragColor = c * scale;\n"
    "    gl_FragColor.a = gl_Color.a;\n"
    "#endif\n"
    "}\n"
;

const char* zooming =
    "struct Shading\n"
    "{\n"
    "    float Ka; // ambient\n"
    "    float Kd; // diffuse\n"
    "    float Ks; // specular\n"
    "    float S;  // shininess\n"
    "};\n"
    "\n"
    "vec3 ShadingNone( in Shading shading, in vec3 color )\n"
    "{\n"
    "    return( color );\n"
    "}\n"
    "\n"
    "vec3 ShadingLambert( in Shading shading, in vec3 color, in vec3 L, in vec3 N )\n"
    "{\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "\n"
    "    return( color * ( Ia + Id ) );\n"
    "}\n"
    "\n"
    "vec3 ShadingPhong( in Shading shading, in vec3 color, in vec3 L, in vec3 N, in vec3 V )\n"
    "{\n"
    "    vec3 R = reflect( -L, N );\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "    float ds = pow( max( dot( R, V ), 0.0 ), shading.S );\n"
    "    if ( dd <= 0.0 ) ds = 0.0;\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "    float Is = shading.Ks * ds;\n"
    "\n"
    "    return( color * ( Ia + Id ) + Is );\n"
    "}\n"
    "\n"
    "vec3 ShadingBlinnPhong( in Shading shading, in vec3 color, in vec3 L, in vec3 N, in vec3 V )\n"
    "{\n"
    "    vec3 H = normalize( L + V );\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "    float ds = pow( max( dot( H, N ), 0.0 ), shading.S );\n"
    "    if ( dd <= 0.0 ) ds = 0.0;\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "    float Is = shading.Ks * ds;\n"
    "\n"
    "    return( color * ( Ia + Id ) + Is );\n"
    "}\n"
    "\n"
    "varying vec3  position;\n"
    "varying vec3  normal;\n"
    "varying vec2  center;\n"
    "varying float radius;\n"
    "\n"
    "uniform Shading shading;\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    // Discard a pixel outside circle.\n"
    "    if ( radius > 0.0 )\n"
    "    {\n"
    "        if( distance( gl_FragCoord.xy, center ) > radius ) discard;\n"
    "    }\n"
    "\n"
    "    // Light position.\n"
    "    vec3 light_position = gl_LightSource[0].position.xyz;\n"
    "\n"
    "    // Light vector (L) and Normal vector (N)\n"
    "    vec3 L = normalize( light_position - position );\n"
    "    vec3 N = normalize( gl_NormalMatrix * normal );\n"
    "\n"
    "#if   defined( ENABLE_LAMBERT_SHADING )\n"
    "    vec3 shaded_color = ShadingLambert( shading, gl_Color.xyz, L, N );\n"
    "\n"
    "#elif defined( ENABLE_PHONG_SHADING )\n"
    "    vec3 V = normalize( -position );\n"
    "    vec3 shaded_color = ShadingPhong( shading, gl_Color.xyz, L, N, V );\n"
    "\n"
    "#elif defined( ENABLE_BLINN_PHONG_SHADING )\n"
    "    vec3 V = normalize( -position );\n"
    "    vec3 shaded_color = ShadingBlinnPhong( shading, gl_Color.xyz, L, N, V );\n"
    "\n"
    "#else // DISABLE SHADING\n"
    "    vec3 shaded_color = ShadingNone( shading, gl_Color.xyz );\n"
    "#endif\n"
    "\n"
    "    gl_FragColor.xyz = shaded_color;\n"
    "    gl_FragColor.w = 1.0;\n"
    "}\n"
;

} // end of namespace Fragment

} // end of namespace ParticleVolumeRenderer

} } } // end of namespace kvs, glew, glsl

#endif // KVS__GLEW__GLSL__ParticleVolumeRenderer_H_INCLUDE
